(racket-define sig       (racket-make-hash))

(racket-define -         racket--)
(racket-define /         racket-/)
(racket-define *         racket-*)
(racket-define cons      racket-mcons)
(racket-define inside    racket-get-output-string)
(racket-define instring  racket-open-input-string)
(racket-define nil       (racket-quote nil))
(racket-define outstring racket-open-output-string)
(racket-define t         (racket-quote t))
(racket-define uniq      racket-gensym)

(racket-define (ar-r/list-toarc x)
  (racket-cond
   ((racket-pair? x)
    (racket-mcons (racket-car x) (ar-r/list-toarc (racket-cdr x))))
   ((racket-null? x)
    (racket-quote nil))
   (racket-else x)))

(racket-define (list . args)
  (ar-r/list-toarc args))

(racket-define (ar-list-fromarc x)
  (racket-cond
   ((racket-mpair? x)
    (racket-cons (racket-mcar x) (ar-list-fromarc (racket-mcdr x))))
   ((racket-eq? x (racket-quote nil))
    (racket-quote ()))
   (racket-else x)))

(racket-define (ar-toarc x)
  (racket-cond
   ((racket-pair? x)
    (racket-mcons (ar-toarc (racket-car x))
                  (ar-toarc (racket-cdr x))))
   ((racket-null? x)
    nil)
   ((racket-string? x)
    (racket-string-copy x))
   (racket-else x)))

(racket-define (ar-strict-deep-fromarc x)
  (racket-cond ((racket-eq? x nil)
                (racket-quote ()))
               ((racket-mpair? x)
                (racket-cons (ar-strict-deep-fromarc (racket-mcar x))
                             (ar-strict-deep-fromarc (racket-mcdr x))))
               (racket-else
                x)))

(racket-define (ar-deep-fromarc x)
  (racket-cond
   ((racket-and (racket-mpair? x)
                (racket-eq? (racket-mcar x)
                            (racket-quote kGsx4AFTTn-racket-list)))
    (ar-strict-deep-fromarc (racket-mcar (racket-mcdr x))))

   ;; nil in the car position isn't a list terminator, and so can
   ;; be left alone.
   ((racket-mpair? x)
    (racket-cons (racket-let ((a (racket-mcar x)))
                   (racket-if (racket-eq? a nil)
                                nil
                                (ar-deep-fromarc a)))
                 (racket-let ((b (racket-mcdr x)))
                   (racket-if (racket-eq? b nil)
                               (racket-quote ())
                               (ar-deep-fromarc b)))))
   (racket-else
    x)))

(racket-define err racket-error)

(racket-define (car x)
  (racket-if (racket-eq? x (racket-quote nil))
              (racket-quote nil)
              (racket-mcar x)))

(racket-define (cdr x)
  (racket-if (racket-eq? x (racket-quote nil))
              (racket-quote nil)
              (racket-mcdr x)))

(racket-define (cadr x)
  (car (cdr x)))

(racket-define (cddr x)
  (cdr (cdr x)))

(racket-define (ar-exint x)
  (racket-and (racket-integer? x) (racket-exact? x)))

(racket-define (ar-tagged x)
  (racket-and (racket-vector? x)
              (racket-eq? (racket-vector-ref x 0) (racket-quote tagged))))

(racket-define (rep x)
  (racket-if (ar-tagged x)
              (racket-vector-ref x 2)
              x))

(racket-define (type x)
  (racket-cond
   ((ar-tagged x)             (racket-vector-ref x 1))
   ((racket-mpair? x)         (racket-quote cons))
   ((racket-symbol? x)        (racket-quote sym))
   ((racket-parameter? x)     (racket-quote parameter))
   ((racket-procedure? x)     (racket-quote fn))
   ((racket-char? x)          (racket-quote char))
   ((racket-string? x)        (racket-quote string))
   ((ar-exint x)              (racket-quote int))
   ((racket-number? x)        (racket-quote num))
   ((racket-hash? x)          (racket-quote table))
   ((racket-output-port? x)   (racket-quote output))
   ((racket-input-port? x)    (racket-quote input))
   ((racket-tcp-listener? x)  (racket-quote socket))
   ((racket-exn? x)           (racket-quote exception))
   ((racket-thread? x)        (racket-quote thread))
   ((racket-thread-cell? x)   (racket-quote thread-cell))
   ((racket-semaphore? x)     (racket-quote semaphore))
   (racket-else               (racket-quote unknown))))

(racket-define (annotate totype rep)
  (racket-cond
   ((racket-eqv? (type rep) totype) rep)
   (racket-else (racket-vector (racket-quote tagged) totype rep))))

(racket-define (ar-tnil x)
  (racket-if x (racket-quote t) (racket-quote nil)))

(racket-define (ar-no x)
  (racket-eq? x nil))

(racket-define (ar-true x)
  (racket-not (ar-no x)))

(racket-define (map1 f xs)
  (racket-if (ar-no xs)
              nil
              (cons (f (car xs)) (map1 f (cdr xs)))))

(racket-define (ar-iround x)
  (racket-inexact->exact (racket-round x)))

(racket-define (coerce x totype . args)
  (racket-cond
    ((ar-tagged x)
     (err "Can't coerce annotated object"))
    ((racket-eqv? totype (type x))
     x)
    ((racket-char? x)
     (racket-case totype
       ((int)       (racket-char->integer x))
       ((string)    (racket-string x))
       ((sym)       (racket-string->symbol (racket-string x)))
       (racket-else (err "Can't coerce" x type))))
    ((ar-exint x)
     (racket-case totype
       ((num)       x)
       ((char)      (racket-integer->char x))
       ((string)    (racket-apply racket-number->string x args))
       (racket-else (err "Can't coerce" x type))))
    ((racket-number? x)
     (racket-case totype
       ((int)       (ar-iround x))
       ((char)      (racket-integer->char (ar-iround x)))
       ((string)    (racket-apply racket-number->string x args))
       (racket-else (err "Can't coerce" x type))))
    ((racket-string? x)
     (racket-case totype
       ((sym)       (racket-string->symbol x))
       ((cons)      (ar-r/list-toarc (racket-string->list x)))
       ((num)       (racket-or (racket-apply racket-string->number x args)
                               (err "Can't coerce" x totype)))
       ((int)       (racket-let ((n (racket-apply racket-string->number x args)))
                      (racket-if n
                                  (ar-iround n)
                                  (err "Can't coerce" x totype))))
       (racket-else (err "Can't coerce" x totype))))
    ((racket-mpair? x)
     (racket-case totype
       ((string)    (racket-apply racket-string-append
                                  (ar-list-fromarc
                                   (map1 (racket-lambda (y)
                                           (coerce y (racket-quote string)))
                                         x))))
       (racket-else (err "Can't coerce" x totype))))
    ((racket-eq? x (racket-quote nil))
     (racket-case totype
       ((string)    "")
       ((cons)      (racket-quote nil))
       (racket-else (err "Can't coerce" x type))))
    ((racket-symbol? x)
     (racket-case totype
       ((string)    (racket-symbol->string x))
       (racket-else (err "Can't coerce" x type))))
    (racket-else x)))

(racket-define (ar-pairwise pred lst)
  (racket-cond
    ((racket-null? lst) (racket-quote t))
    ((racket-null? (racket-cdr lst)) (racket-quote t))
    ((racket-not (racket-eqv? (pred (racket-car lst) (racket-cadr lst))
                              (racket-quote nil)))
     (ar-pairwise pred (racket-cdr lst)))
    (racket-else (racket-quote nil))))
  
(racket-define (is2 a b)
  (ar-tnil
   (racket-or (racket-eqv? a b)
              (racket-and (racket-string? a)
                          (racket-string? b)
                          (racket-string=? a b)))))

(racket-define (is . args)
  (ar-pairwise is2 (ar-list-fromarc args)))


(racket-define (caris x val)
  (ar-tnil
   (racket-and (racket-mpair? x)
               (ar-true (is (car x) val)))))

;; <

(racket-define (<2 x y)
  (ar-tnil
   (racket-cond
    ((racket-and (racket-number? x) (racket-number? y)) (racket-< x y))
    ((racket-and (racket-string? x) (racket-string? y)) (racket-string<? x y))
    ((racket-and (racket-symbol? x) (racket-symbol? y))
     (racket-string<? (racket-symbol->string x)
                      (racket-symbol->string y)))
    ((racket-and (racket-char? x) (racket-char? y)) (racket-char<? x y))
    (racket-else (err "Can't <" x y)))))

(racket-define (< . args)
  (ar-pairwise <2 (ar-list-fromarc args)))

(racket-define (>2 x y)
  (ar-tnil
   (racket-cond
    ((racket-and (racket-number? x) (racket-number? y)) (racket-> x y))
    ((racket-and (racket-string? x) (racket-string? y)) (racket-string>? x y))
    ((racket-and (racket-symbol? x) (racket-symbol? y))
     (racket-string>? (racket-symbol->string x) (racket-symbol->string y)))
    ((racket-and (racket-char? x) (racket-char? y)) (racket-char>? x y))
    (racket-else (err "Can't >" x y)))))

(racket-define (> . args)
  (ar-pairwise >2 (ar-list-fromarc args)))

(racket-define (list-len x)
  (racket-cond
   ((ar-no x)         0)
   ((racket-mpair? x) (racket-+ 1 (list-len (racket-mcdr x))))
   (racket-else       (err "len expects a proper list"))))

(racket-define (len x)
  (racket-cond
   ((racket-string? x) (racket-string-length x))
   ((racket-hash? x)   (racket-hash-count x))
   (racket-else        (list-len x))))

(racket-define (join . args)
  (ar-r/list-toarc
   (racket-apply racket-append
                 (racket-map ar-list-fromarc (ar-list-fromarc args)))))

(racket-define (ar-alist x)
  (racket-or (ar-no x) (racket-mpair? x)))

(racket-define (+ . args)
  (racket-cond
   ((racket-null? args)
    0)
   ((racket-or (racket-char? (racket-car args))
               (racket-string? (racket-car args)))
    (racket-apply racket-string-append
                  (racket-map (racket-lambda (a)
                                (coerce a (racket-quote string)))
                              args)))
   ((ar-alist (racket-car args))
    (racket-apply join args))
   (racket-else
    (racket-apply racket-+ args))))

(racket-define (peekc (port (racket-current-input-port)))
  (racket-let ((c (racket-peek-char port)))
    (racket-if (racket-eof-object? c) (racket-quote nil) c)))

(racket-define (readc (port (racket-current-input-port))
                      (eof (racket-quote nil)))
  (racket-let ((c (racket-read-char port)))
    (racket-if (racket-eof-object? c) eof c)))

(racket-define (writec c (port (racket-current-output-port)))
  (racket-write-char c port))

(racket-define (racket-module-ref a/module)
  (racket-let ((r/module (ar-deep-fromarc a/module)))
    (racket-lambda (sym)
      (racket-dynamic-require r/module sym))))

(racket-define (ar-apply-cons fn . racket-arg-list)
  (racket-mlist-ref fn (racket-car racket-arg-list)))

(racket-define (ar-apply-string fn . racket-arg-list)
  (racket-string-ref fn (racket-car racket-arg-list)))

(racket-define (ar-apply-table fn . racket-arg-list)  
  (racket-hash-ref fn
    (racket-car racket-arg-list)
    (racket-let ((default
                  (racket-if (racket-pair? (racket-cdr racket-arg-list))
                              (racket-car (racket-cdr racket-arg-list))
                              (racket-quote nil))))
      (racket-lambda () default))))

(racket-define (ar-apply fn . racket-arg-list)
  (racket-cond
   ((racket-procedure? fn)
    (racket-apply fn racket-arg-list))
   ((racket-mpair? fn)
    (racket-apply ar-apply-cons fn racket-arg-list))
   ((racket-string? fn)
    (racket-apply ar-apply-string fn racket-arg-list))
   ((racket-hash? fn)
    (racket-apply ar-apply-table fn racket-arg-list))
   (racket-else
    (err "Function call on inappropriate object" fn racket-arg-list))))

(racket-define (ar-funcall0 fn)
  (racket-if (racket-procedure? fn)
              (fn)
              (ar-apply fn)))

(racket-define (ar-funcall1 fn arg1)
  (racket-if (racket-procedure? fn)
               (fn arg1)
               (ar-apply fn arg1)))

(racket-define (ar-funcall2 fn arg1 arg2)
  (racket-if (racket-procedure? fn)
              (fn arg1 arg2)
              (ar-apply fn arg1 arg2)))

(racket-define (ar-funcall3 fn arg1 arg2 arg3)
  (racket-if (racket-procedure? fn)
              (fn arg1 arg2 arg3)
              (ar-apply fn arg1 arg2 arg3)))

(racket-define (ar-funcall4 fn arg1 arg2 arg3 arg4)
  (racket-if (racket-procedure? fn)
              (fn arg1 arg2 arg3 arg4)
              (ar-apply fn arg1 arg2 arg3 arg4)))

(racket-define (ar-combine-args as)
  (racket-let next ((as as) (accum (racket-list)))
    (racket-cond
     ((racket-null? as)
      accum)
     ((racket-null? (racket-cdr as))
      (racket-append accum (ar-list-fromarc (racket-car as))))
     (racket-else
      (next (racket-cdr as)
            (racket-append accum (racket-list (racket-car as))))))))

(racket-define (apply fn . args)
  (racket-apply ar-apply fn (ar-combine-args args)))
